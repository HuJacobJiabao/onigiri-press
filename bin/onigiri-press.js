#!/usr/bin/env node

import { Command } from 'commander';
import fs from 'fs';
import path from 'path';
import { execSync, spawn } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const program = new Command();

program
  .name('ongr')
  .description('OnigiriPress - A modern portfolio framework')
  .version('1.2.8');

program
  .command('init [project-name]')
  .description('Initialize a new OnigiriPress project')
  .action((projectName = 'my-portfolio') => {
    console.log(`üçô Creating new OnigiriPress project: ${projectName}`);
    
    const projectPath = path.join(process.cwd(), projectName);
    
    // Create project directory
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
    }
    
    // Copy essential files
    const packageDir = path.dirname(__dirname);
    
    console.log('üìÅ Setting up project structure...');
    
    // Copy config files
    const configTemplate = path.join(packageDir, 'config.template.yaml');
    const configTarget = path.join(projectPath, 'config.yaml');
    if (fs.existsSync(configTemplate)) {
      fs.copyFileSync(configTemplate, configTarget);
      console.log('   ‚úì Created config.yaml');
    }
    
    // Copy onigiri.config.json
    const onigiriConfigTemplate = path.join(packageDir, 'onigiri.config.json');
    const onigiriConfigTarget = path.join(projectPath, 'onigiri.config.json');
    if (fs.existsSync(onigiriConfigTemplate)) {
      fs.copyFileSync(onigiriConfigTemplate, onigiriConfigTarget);
      console.log('   ‚úì Created onigiri.config.json');
    }

    // Note: We don't copy index.html - it will be used from the package itself

    // Copy package.json template
    const packageTemplate = path.join(packageDir, 'package-user.json');
    const packageTarget = path.join(projectPath, 'package.json');
    if (fs.existsSync(packageTemplate)) {
      fs.copyFileSync(packageTemplate, packageTarget);
      console.log('   ‚úì Created package.json');
    }
    
    
    // Copy public directory
    const publicDir = path.join(packageDir, 'public');
    const publicTarget = path.join(projectPath, 'public');
    if (fs.existsSync(publicDir)) {
      fs.cpSync(publicDir, publicTarget, { recursive: true });
      console.log('   ‚úì Copied public/ directory');
    }
    
    // Copy templates directory
    const templatesDir = path.join(packageDir, 'templates');
    const templatesTarget = path.join(projectPath, 'templates');
    if (fs.existsSync(templatesDir)) {
      fs.cpSync(templatesDir, templatesTarget, { recursive: true });
      console.log('   ‚úì Copied templates/ directory');
    }

    // Copy gitignore
    const gitignoreTemplate = path.join(packageDir, 'gitignore.template');
    const gitignoreTarget = path.join(projectPath, '.gitignore');
    if (fs.existsSync(gitignoreTemplate)) {
      fs.copyFileSync(gitignoreTemplate, gitignoreTarget);
      console.log('   ‚úì Created .gitignore');
    }
    
    // Copy README
    const readmeTemplate = path.join(packageDir, 'README.template.md');
    const readmeTarget = path.join(projectPath, 'README.md');
    if (fs.existsSync(readmeTemplate)) {
      fs.copyFileSync(readmeTemplate, readmeTarget);
      console.log('   ‚úì Created README.md');
    }
    
    console.log('‚úÖ Project created successfully!');
    console.log(`üìù Next steps:`);
    console.log(`   cd ${projectName}`);
    console.log(`   npm install`);
    console.log(`   ongr dev`);
  });

// Read baseUrl from config files
function getBaseUrl(userDir) {
  // First try to read from onigiri.config.json (fastest)
  const configJsonPath = path.join(userDir, 'onigiri.config.json');
  if (fs.existsSync(configJsonPath)) {
    try {
      const configJson = JSON.parse(fs.readFileSync(configJsonPath, 'utf8'));
      if (configJson.baseUrl) {
        // console.log(`üìç Using baseUrl from onigiri.config.json: ${configJson.baseUrl}`);
        return configJson.baseUrl;
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Error reading onigiri.config.json, trying config.yaml...');
    }
  }
  
  // Fall back to config.yaml if needed
  const configYamlPath = path.join(userDir, 'config.yaml');
  if (fs.existsSync(configYamlPath)) {
    try {
      const configContent = fs.readFileSync(configYamlPath, 'utf8');
      
      // This is a simple string search approach instead of full YAML parsing
      const baseUrlMatch = configContent.match(/baseUrl:\s*["']?([^"']+)["']?/);
      if (baseUrlMatch && baseUrlMatch[1]) {
        const baseUrl = baseUrlMatch[1];
        // console.log(`üìç Using baseUrl from config.yaml: ${baseUrl}`);
        return baseUrl;
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Error reading baseUrl from config.yaml');
    }
  }
  
  // Default fallback
  // console.log('üìç Using default baseUrl: /');
  return '/';
}

program
  .command('dev')
  .description('Start development server')
  .action(() => {
    console.log('üöÄ Starting development server...');
    try {
      const userDir = process.cwd();
      const packageDir = path.dirname(__dirname);
      const preprocessScript = path.join(packageDir, 'src', 'scripts', 'preprocess-content.ts');
      
      // First run preprocessing from global package location
      console.log('üîÑ Step 1: Preprocessing content...');
      execSync(`npx tsx "${preprocessScript}"`, { 
        stdio: 'inherit', 
        cwd: userDir,
        env: { ...process.env, NODE_PATH: packageDir }
      });
      
      // Get baseUrl from config for development
      const baseUrl = getBaseUrl(userDir);
      
      console.log('üî• Step 2: Starting development server...');
      execSync('npx vite', { 
        stdio: 'inherit', 
        cwd: packageDir,
        env: { 
          ...process.env, 
          VITE_USER_DIR: userDir,
          VITE_BASE_URL: baseUrl
        }
      });
    } catch (error) {
      console.error('‚ùå Failed to start development server');
      process.exit(1);
    }
  });

program
  .command('build')
  .description('Build for production')
  .action(async () => {
    console.log('üî® Building for production...');
    try {
      const userDir = process.cwd();
      const packageDir = path.dirname(__dirname);
      const preprocessScript = path.join(packageDir, 'src', 'scripts', 'preprocess-content.ts');
      
      // First run preprocessing from global package location
      console.log('üîÑ Step 1: Preprocessing content...');
      execSync(`npx tsx "${preprocessScript}"`, { 
        stdio: 'inherit', 
        cwd: userDir,
        env: { ...process.env, NODE_PATH: packageDir }
      });
      
      // Get baseUrl from config for production build
      const baseUrl = getBaseUrl(userDir);
      
      console.log('üî® Step 2: Building with Vite...');
      
      // Run vite build from the package directory (where all dependencies exist)
      // but output to the user directory
      const viteBuild = spawn('npx', ['vite', 'build'], {
        cwd: packageDir,
        env: { 
          ...process.env, 
          VITE_USER_DIR: userDir,
          VITE_BASE_URL: baseUrl,
          NODE_ENV: 'production',
          FORCE_COLOR: '1' // Preserve terminal colors
        },
        stdio: ['inherit', 'pipe', 'pipe']
      });
      
      // Process stdout line by line to clean paths in real-time
      viteBuild.stdout.on('data', (data) => {
        const output = data.toString();
        // Replace long absolute paths and relative paths with cleaner ones
        let cleanedOutput = output
          // Remove complex relative paths like ../../../../../../../portfolio/dist/
          .replace(/(?:\.\.\/)+[^/\s]*\/dist\//g, 'dist/')
          // Also clean any remaining complex paths
          .replace(/.*?onigiri-test.*?\/dist\//g, 'dist/')
          // Clean paths that start with many ../
          .replace(/(?:\.\.\/){3,}[^/\s]*\//g, '')
          // Clean any remaining long absolute paths to user directories
          .replace(/\/[^/\s]*\/[^/\s]*\/[^/\s]*\/portfolio\/dist\//g, 'dist/');
        process.stdout.write(cleanedOutput);
      });
      
      // Pass stderr through unchanged
      viteBuild.stderr.on('data', (data) => {
        process.stderr.write(data);
      });
      
      // Wait for build to complete
      await new Promise((resolve, reject) => {
        viteBuild.on('close', (code) => {
          if (code === 0) {
            resolve();
          } else {
            reject(new Error(`Build failed with exit code ${code}`));
          }
        });
      });
      
      console.log('‚úÖ Build completed!');
    } catch (error) {
      console.error('‚ùå Build failed');
      process.exit(1);
    }
  });

program
  .command('generate <type> <name>')
  .alias('g')
  .description('Generate new content (blog|project). Use aliases: g for generate, b for blog, p for project')
  .action((type, name) => {
    // Support aliases for content types
    const typeMap = {
      'b': 'blog',
      'blog': 'blog',
      'p': 'project', 
      'project': 'project'
    };
    
    const actualType = typeMap[type.toLowerCase()];
    if (!actualType) {
      console.error(`‚ùå Invalid type: ${type}. Use 'blog' (or 'b') or 'project' (or 'p')`);
      process.exit(1);
    }
    
    console.log(`üìù Generating new ${actualType}: ${name}`);
    
    // Find the onigiri-press package directory
    const packageDir = path.dirname(__dirname);
    const generateScript = path.join(packageDir, 'src', 'scripts', 'generate.ts');
    
    try {
      // Use tsx to run the TypeScript script directly
      execSync(`npx tsx "${generateScript}" ${actualType} "${name}"`, { 
        stdio: 'inherit', 
        cwd: process.cwd(),
        env: { ...process.env, NODE_PATH: packageDir }
      });
    } catch (error) {
      console.error(`‚ùå Failed to generate ${actualType}`);
      process.exit(1);
    }
  });

program
  .command('load')
  .alias('l')
  .description('Load and preprocess content files (blogs and projects)')
  .action(() => {
    console.log('üîÑ Loading and preprocessing content...');
    
    // Find the onigiri-press package directory
    const packageDir = path.dirname(__dirname);
    const preprocessScript = path.join(packageDir, 'src', 'scripts', 'preprocess-content.ts');
    
    try {
      // Use tsx to run the preprocessing script directly
      execSync(`npx tsx "${preprocessScript}"`, { 
        stdio: 'inherit', 
        cwd: process.cwd(),
        env: { ...process.env, NODE_PATH: packageDir }
      });
      console.log('‚úÖ Content preprocessing completed!');
    } catch (error) {
      console.error('‚ùå Content preprocessing failed');
      console.error('Error details:', error.message);
      process.exit(1);
    }
  });

program
  .command('deploy')
  .alias('d')
  .description('Deploy to GitHub Pages (requires manual build first)')
  .option('-b, --base <url>', 'Override base URL for deployment')
  .action(async (options) => {
    console.log('üöÄ Deploying to GitHub Pages...');
    
    try {
      // Check if dist directory exists
      if (!fs.existsSync('dist')) {
        console.error('‚ùå No dist directory found!');
        console.error('üí° Please run "ongr build" first to create the production build');
        process.exit(1);
      }
      
      // Read config to get deployment settings
      let baseUrl = '/';
      let repoName = 'my-portfolio';
      let isUserRepo = false;
      
      // First, try to read from onigiri.config.json
      if (fs.existsSync('onigiri.config.json')) {
        const onigiriConfigContent = fs.readFileSync('onigiri.config.json', 'utf8');
        const onigiriConfig = JSON.parse(onigiriConfigContent);
        
        if (onigiriConfig.baseUrl) {
          baseUrl = onigiriConfig.baseUrl;
          console.log(`üìç Using base URL from onigiri.config.json: ${baseUrl}`);
        }
        
        // Extract repository name from baseUrl if it follows GitHub Pages pattern
        if (baseUrl !== '/' && baseUrl.startsWith('/') && baseUrl.endsWith('/')) {
          const pathPart = baseUrl.slice(1, -1); // Remove leading and trailing slashes
          if (pathPart && !pathPart.includes('/')) {
            repoName = pathPart;
            console.log(`üì¶ Detected repository name from baseUrl: ${repoName}`);
          }
        }
      } else {
        console.log('‚ö†Ô∏è  No onigiri.config.json found, using default settings');
      }
      
      // Allow command line override
      if (options.base) {
        baseUrl = options.base;
        console.log(`üìç Using custom base URL from command line: ${baseUrl}`);
      }
      
      // Check if this looks like a user/organization repository
      isUserRepo = baseUrl === '/';
      
      if (isUserRepo) {
        console.log(`üìç Detected user/org repository, using base URL: /`);
      } else {
        console.log(`üìç Detected project repository, using base URL: ${baseUrl}`);
      }
      
      // Deploy with gh-pages
      console.log('üåê Deploying to GitHub Pages...');
      // Use nojekyll option to add .nojekyll without including other dotfiles like .gitignore
      execSync('npx gh-pages -d dist --nojekyll --remove ".*"', { stdio: 'inherit', cwd: process.cwd() });
      
      console.log('‚úÖ Deployment completed successfully!');
      if (isUserRepo) {
        console.log(`üéâ Your site should be available at: https://<username>.github.io/`);
        console.log('üí° Replace <username> with your actual GitHub username');
      } else {
        console.log(`üéâ Your site should be available at: https://<username>.github.io${baseUrl}`);
        console.log('üí° Replace <username> with your actual GitHub username');
      }
    } catch (error) {
      console.error('‚ùå Deployment failed');
      console.error('üí° Make sure you have:');
      console.error('   ‚Ä¢ Run "ongr build" to create a production build');
      console.error('   ‚Ä¢ Initialized a git repository');
      console.error('   ‚Ä¢ Set up GitHub Pages in your repository settings');
      console.error('   ‚Ä¢ Pushed your code to GitHub');
      console.error('   ‚Ä¢ Configured baseUrl in onigiri.config.json (if needed)');
      process.exit(1);
    }
  });

program
  .command('deploy-vercel')
  .alias('dv')
  .description('Deploy to Vercel')
  .option('--prod', 'Deploy to production (default: preview)')
  .action(async (options) => {
    console.log('üöÄ Deploying to Vercel...');
    
    try {
      // Check if user has vercel CLI installed
      try {
        execSync('vercel --version', { stdio: 'pipe' });
      } catch (error) {
        console.error('‚ùå Vercel CLI not found!');
        console.error('üí° Please install it first:');
        console.error('   npm install -g vercel');
        console.error('   # or');
        console.error('   pnpm add -g vercel');
        process.exit(1);
      }
      
      // Create vercel.json if it doesn't exist
      if (!fs.existsSync('vercel.json')) {
        console.log('üìù Creating vercel.json configuration...');
        const vercelConfig = {
          buildCommand: "npm run build",
          outputDirectory: "dist",
          installCommand: "npm install",
          framework: null,
          rewrites: [
            {
              source: "/(.*)",
              destination: "/index.html"
            }
          ],
          headers: [
            {
              source: "/assets/(.*)",
              headers: [
                {
                  key: "Cache-Control",
                  value: "public, max-age=31536000, immutable"
                }
              ]
            }
          ]
        };
        fs.writeFileSync('vercel.json', JSON.stringify(vercelConfig, null, 2));
        console.log('‚úÖ Created vercel.json with optimized settings');
      }
      
      // Deploy to Vercel
      console.log('üåê Deploying to Vercel...');
      
      if (options.prod) {
        console.log('ÔøΩ Deploying to production...');
        execSync('vercel --prod', { stdio: 'inherit', cwd: process.cwd() });
      } else {
        console.log('üîç Deploying preview...');
        execSync('vercel', { stdio: 'inherit', cwd: process.cwd() });
      }
      
      console.log('‚úÖ Vercel deployment completed successfully!');
      console.log('üí° Tips:');
      console.log('   ‚Ä¢ Use --prod flag for production deployment');
      console.log('   ‚Ä¢ Vercel will automatically build your project');
      console.log('   ‚Ä¢ Make sure baseUrl is set to "/" in onigiri.config.json for Vercel');
      
    } catch (error) {
      console.error('‚ùå Vercel deployment failed');
      console.error('üí° Make sure you have:');
      console.error('   ‚Ä¢ Installed Vercel CLI: npm install -g vercel');
      console.error('   ‚Ä¢ Logged in to Vercel: vercel login');
      console.error('   ‚Ä¢ Set baseUrl to "/" in onigiri.config.json');
      console.error('Error details:', error.message);
      process.exit(1);
    }
  });

program
  .command('log [date]')
  .description('Create a new daily log entry (date format: yyyy-mm-dd, defaults to today)')
  .action((date) => {
    if (date) {
      // Validate date format
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(date)) {
        console.error('‚ùå Invalid date format. Please use yyyy-mm-dd format (e.g., 2025-06-18)');
        process.exit(1);
      }
      
      // Validate that it's a valid date
      const [year, month, day] = date.split('-').map(Number);
      const testDate = new Date(year, month - 1, day);
      if (testDate.getFullYear() !== year || testDate.getMonth() !== month - 1 || testDate.getDate() !== day) {
        console.error('‚ùå Invalid date. Please provide a valid date in yyyy-mm-dd format');
        process.exit(1);
      }
      
      console.log(`üìù Creating daily log entry for ${date}...`);
    } else {
      console.log('üìù Creating daily log entry for today...');
    }
    
    // Find the onigiri-press package directory
    const packageDir = path.dirname(__dirname);
    const logScript = path.join(packageDir, 'src', 'scripts', 'create-daily-log.ts');
    
    try {
      // Pass the date argument to the script if provided
      const command = date 
        ? `npx tsx "${logScript}" "${date}"` 
        : `npx tsx "${logScript}"`;
        
      execSync(command, { 
        stdio: 'inherit', 
        cwd: process.cwd(),
        env: { ...process.env, NODE_PATH: packageDir }
      });
      console.log('‚úÖ Daily log entry created successfully!');
    } catch (error) {
      console.error('‚ùå Failed to create daily log entry');
      console.error('Error details:', error.message);
      process.exit(1);
    }
  });

program
  .command('update')
  .alias('u')
  .description('Update OnigiriPress to the latest version')
  .option('--check', 'Check for updates without installing')
  .option('--beta', 'Include beta/prerelease versions')
  .action(async (options) => {
    console.log('üîç Checking for OnigiriPress updates...');
    
    try {
      // Get current version
      const packageDir = path.dirname(__dirname);
      const packageJsonPath = path.join(packageDir, 'package.json');
      const currentPackage = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const currentVersion = currentPackage.version;
      
      console.log(`üì¶ Current version: ${currentVersion}`);
      
      // Check latest version from npm
      console.log('üåê Fetching latest version from npm...');
      let versionFlag = options.beta ? '--tag beta' : '';
      const npmViewCmd = `npm view onigiri-press version ${versionFlag}`.trim();
      
      let latestVersion;
      try {
        latestVersion = execSync(npmViewCmd, { 
          encoding: 'utf8',
          stdio: 'pipe'
        }).trim();
      } catch (error) {
        if (options.beta) {
          console.log('‚ö†Ô∏è No beta version found, checking stable...');
          latestVersion = execSync('npm view onigiri-press version', { 
            encoding: 'utf8',
            stdio: 'pipe'
          }).trim();
        } else {
          throw error;
        }
      }
      
      console.log(`üöÄ Latest version: ${latestVersion}`);
      
      // Compare versions
      if (currentVersion === latestVersion) {
        console.log('‚úÖ You are already on the latest version!');
        return;
      }
      
      // Show version comparison
      const isNewer = compareVersions(latestVersion, currentVersion);
      if (isNewer) {
        console.log(`üìà Update available: ${currentVersion} ‚Üí ${latestVersion}`);
        
        // Show changelog if available
        try {
          console.log('\nüìù Recent changes:');
          const changelogCmd = `npm view onigiri-press --json`;
          const packageInfo = JSON.parse(execSync(changelogCmd, { 
            encoding: 'utf8',
            stdio: 'pipe'
          }));
          
          if (packageInfo.description) {
            console.log(`   ${packageInfo.description}`);
          }
          if (packageInfo.homepage) {
            console.log(`   üìö Docs: ${packageInfo.homepage}`);
          }
        } catch (error) {
          // Ignore changelog errors
        }
        
        if (options.check) {
          console.log('\nüí° Run "ongr update" to install the latest version');
          return;
        }
        
        // Confirm update
        console.log('\nüîÑ Updating OnigiriPress...');
        
        // Update globally if installed globally, otherwise update locally
        let updateCmd;
        try {
          // Check if installed globally
          execSync('npm list -g onigiri-press', { stdio: 'pipe' });
          updateCmd = `npm install -g onigiri-press@${latestVersion}`;
          console.log('üì¶ Updating global installation...');
        } catch (error) {
          // Not installed globally, update locally
          updateCmd = `npm install onigiri-press@${latestVersion}`;
          console.log('üì¶ Updating local installation...');
        }
        
        execSync(updateCmd, { stdio: 'inherit' });
        
        console.log('‚úÖ OnigiriPress updated successfully!');
        console.log(`üéâ Updated from ${currentVersion} to ${latestVersion}`);
        console.log('\nüí° Tips:');
        console.log('   ‚Ä¢ Run "ongr --version" to verify the update');
        console.log('   ‚Ä¢ Check the documentation for any breaking changes');
        console.log('   ‚Ä¢ Consider updating your project dependencies');
        
      } else {
        console.log(`‚ö†Ô∏è You are running a newer version than the latest release`);
        console.log(`   Current: ${currentVersion}, Latest: ${latestVersion}`);
      }
      
    } catch (error) {
      console.error('‚ùå Failed to check for updates');
      console.error('üí° Make sure you have internet connection and npm is working');
      console.error('Error details:', error.message);
      process.exit(1);
    }
  });

// Helper function to compare semantic versions
function compareVersions(version1, version2) {
  const v1parts = version1.split('.').map(Number);
  const v2parts = version2.split('.').map(Number);
  
  for (let i = 0; i < Math.max(v1parts.length, v2parts.length); i++) {
    const v1part = v1parts[i] || 0;
    const v2part = v2parts[i] || 0;
    
    if (v1part > v2part) return true;
    if (v1part < v2part) return false;
  }
  
  return false;
}

program.parse();
